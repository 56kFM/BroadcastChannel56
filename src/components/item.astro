---
import '../assets/item.css'
import 'prismjs/themes/prism.css'
import dayjs from '../lib/dayjs'
import { getEnv } from '../lib/env'
import { sanitizeHTML } from '../utils/sanitizeHTML'
import { linkAudioToPlayer } from '../utils/transformAudioLinks'
import { validateEnv } from '../utils/env'
import Embed from './Embed.astro'
import Media from './Media.astro'

const { BASE_URL } = Astro.locals
const { post, isItem } = Astro.props

const validatedEnv = validateEnv({
  env: import.meta.env,
  runtimeEnv: Astro.locals?.runtime?.env,
  isDev: import.meta.env.DEV,
  isBuild: import.meta.env.PROD,
})

const locale = (getEnv(import.meta.env, Astro, 'LOCALE') ?? validatedEnv.locale) || ''
if (locale) {
  dayjs.locale(locale)
}

const timezone = (getEnv(import.meta.env, Astro, 'TIMEZONE') ?? validatedEnv.timezone) || 'UTC'
const channel = getEnv(import.meta.env, Astro, 'CHANNEL') ?? validatedEnv.channel
const COMMENTS = getEnv(import.meta.env, Astro, 'COMMENTS')
const envEmbedSetting = getEnv(import.meta.env, Astro, 'ENABLE_EMBEDS')
const envEmbedsEnabled = envEmbedSetting === undefined ? true : envEmbedSetting !== 'false'

type MediaItem = {
  kind?: string
  url?: string
  mime?: string
  caption?: string
}

type EmbedItem = {
  url: string
  oembedHtml?: string
}

const bandcampIframeStyle = 'border: 0; width: 100%; height: 120px;'

function bandcampPresetIframeFromId(idType: 'album' | 'track', id: string) {
  const src = `https://bandcamp.com/EmbeddedPlayer/${idType}=${id}/size=large/bgcol=333333/linkcol=0f91ff/tracklist=false/artwork=small/transparent=true/`
  return `<iframe style="${bandcampIframeStyle}" src="${src}" loading="lazy" seamless></iframe>`
}

function bandcampPresetIframeFromUrl(url: string) {
  const base = 'https://bandcamp.com/EmbeddedPlayer/'
  const params = 'size=large/bgcol=333333/linkcol=0f91ff/tracklist=false/artwork=small/transparent=true/'
  const src = `${base}?url=${encodeURIComponent(url)}&${params.replace(/\//g, '&')}`
  return `<iframe style="${bandcampIframeStyle}" src="${src}" loading="lazy" seamless></iframe>`
}

const decodeAttributeValue = (value: string) => value.replace(/&amp;/gi, '&')

const safeDecodeURIComponent = (value: string) => {
  try {
    return decodeURIComponent(value)
  } catch {
    return value
  }
}

const rewriteBandcampIframes = (html: string) => {
  return html.replace(
    /<iframe\b[^>]*?\bsrc=(['"])([^'"\s>]+)\1[^>]*?>[\s\S]*?<\/iframe>/gi,
    (match, _quote, rawSrc) => {
      const normalizedSrc = decodeAttributeValue(rawSrc)
      if (!/bandcamp\.com\/EmbeddedPlayer/i.test(normalizedSrc)) {
        return match
      }

      const idMatch = normalizedSrc.match(/\b(album|track)=(\d+)/i)
      if (idMatch) {
        const idType = idMatch[1].toLowerCase() as 'album' | 'track'
        return bandcampPresetIframeFromId(idType, idMatch[2])
      }

      const urlMatch = normalizedSrc.match(/[?&]url=([^&]+)/i)
      if (urlMatch) {
        const decodedUrl = safeDecodeURIComponent(urlMatch[1])
        return bandcampPresetIframeFromUrl(decodedUrl)
      }

      return match
    },
  )
}

const isBandcampPlayableUrl = (rawUrl: string) => {
  try {
    const url = new URL(rawUrl)
    const hostname = url.hostname.toLowerCase()
    if (!hostname.endsWith('.bandcamp.com')) {
      return false
    }

    const path = url.pathname.toLowerCase()
    return path.includes('/album/') || path.includes('/track/')
  } catch {
    return false
  }
}

const convertBandcampLinks = (html: string) => {
  return html.replace(
    /<a\b([^>]*?)\bhref=(['"])([^'"\s>]+)\2([^>]*)>[\s\S]*?<\/a>/gi,
    (match, _before, _quote, rawHref, _after) => {
      const normalizedHref = decodeAttributeValue(rawHref)
      if (!isBandcampPlayableUrl(normalizedHref)) {
        return match
      }

      return bandcampPresetIframeFromUrl(normalizedHref)
    },
  )
}

const normalizeBandcampEmbeds = (html: string) => {
  if (!html || !/bandcamp\.com/i.test(html)) {
    return html
  }

  const withRewrittenIframes = rewriteBandcampIframes(html)
  return convertBandcampLinks(withRewrittenIframes)
}

let safeContent = ''
let mediaList: MediaItem[] = []
let embedList: EmbedItem[] = []
let shouldRenderEmbeds = false
let renderError: Error | null = null

const fallbackText = typeof post?.text === 'string' ? post.text : ''
const fallbackTransformed = fallbackText ? linkAudioToPlayer(fallbackText) : ''
const fallbackSanitizedHtml = fallbackTransformed ? sanitizeHTML(fallbackTransformed) : ''
const fallbackSafeHtml = fallbackSanitizedHtml ? normalizeBandcampEmbeds(fallbackSanitizedHtml) : ''
const fallbackLinkUrls = new Set<string>()

const allowListedUrl = (value: string | undefined | null) => {
  if (typeof value !== 'string') {
    return null
  }

  const trimmed = value.trim()
  if (!/^https?:/iu.test(trimmed)) {
    return null
  }

  return trimmed
}

if (Array.isArray(post?.embeds)) {
  post.embeds.forEach((embed) => {
    const safeUrl = allowListedUrl(embed?.url)
    if (safeUrl) {
      fallbackLinkUrls.add(safeUrl)
    }
  })
}

if (Array.isArray(post?.media)) {
  post.media.forEach((media) => {
    const safeUrl = allowListedUrl(media?.url)
    if (safeUrl) {
      fallbackLinkUrls.add(safeUrl)
    }
  })
}

const fallbackLinks = Array.from(fallbackLinkUrls).map((url) => ({ url }))

try {
  const rawContent = typeof post?.content === 'string' ? post.content : ''
  const transformedContent = rawContent ? linkAudioToPlayer(rawContent) : ''
  const sanitizedContent = transformedContent ? sanitizeHTML(transformedContent) : ''
  const normalizedContent = sanitizedContent ? normalizeBandcampEmbeds(sanitizedContent) : ''
  safeContent = normalizedContent
  mediaList = Array.isArray(post?.media)
    ? post.media.filter((media): media is MediaItem =>
        Boolean(media && typeof media.url === 'string' && media.url.length > 0),
      )
    : []
  embedList = Array.isArray(post?.embeds)
    ? post.embeds.filter((embed): embed is EmbedItem =>
        Boolean(embed && typeof embed.url === 'string' && embed.url.length > 0),
      )
    : []
  const embedsEnabled = envEmbedsEnabled && (post?.embedsEnabled ?? envEmbedsEnabled)
  shouldRenderEmbeds = embedsEnabled && embedList.length > 0
} catch (error) {
  renderError = error instanceof Error ? error : new Error('Failed to render post content')
  if (import.meta.env.DEV) {
    console.warn('Failed to render post content', {
      id: post?.id,
      error: renderError,
    })
  }
}

const datetimeSource = typeof post?.datetime === 'string' ? post.datetime : ''
const datetime = (datetimeSource ? dayjs(datetimeSource) : dayjs()).tz(timezone)
const timeago = datetime.isBefore(dayjs().subtract(1, 'w')) ? datetime.format('HH:mm · ll · ddd') : datetime.fromNow()
---

<div class="item" style={{ 'view-transition-name': `post-${post.id}` }}>
  <div class="item-content-container">
    {
      renderError ? (
        <div class="text-box content">
          {fallbackSafeHtml.length > 0 ? (
            <div set:html={fallbackSafeHtml} />
          ) : (
            fallbackText.length > 0 && <p>{fallbackText}</p>
          )}
          {fallbackLinks.map((link) => (
            <p class="embed-fallback" key={`fallback-link-${link.url}`}>
              <a href={link.url} rel="noopener noreferrer nofollow ugc">
                {link.url}
              </a>
            </p>
          ))}
        </div>
      ) : (
        <Fragment>
          {safeContent.length > 0 && <div class={`text-box content`} set:html={safeContent} />}

          {mediaList.length > 0 && (
            <div class="media-list">
              {mediaList.map((media, index) => (
                <Media {...media} key={`media-${post.id ?? index}-${index}`} />
              ))}
            </div>
          )}

          {shouldRenderEmbeds && (
            <div class="embed-list">
              {embedList.map((embed, index) => (
                <div class="embed-item" key={`embed-${post.id ?? index}-${index}`}>
                  <Embed url={embed.url} oembedHtml={embed.oembedHtml} />
                </div>
              ))}
            </div>
          )}
        </Fragment>
      )
    }
  </div>

  <div class="time-box">
    <div class="time">
      <a href={`${BASE_URL}posts/${post.id}`} title={post.datetime} class="time-link">
        <time datetime={post.datetime} title={timeago}>{timeago}</time>
      </a>
    </div>
  </div>

  {
    COMMENTS && isItem && (
      <div class="comments">
        <script
          is:inline
          async
          src="https://telegram.org/js/telegram-widget.js"
          data-telegram-discussion={`${channel}/${post.id}`}
          data-comments-limit="50"
          data-colorful="1"
          data-dark="1"
        />
      </div>
    )
  }
</div>
