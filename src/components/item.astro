---
import '../assets/item.css'
import 'prismjs/themes/prism.css'
import dayjs from '../lib/dayjs'
import { getEnv } from '../lib/env'
import { sanitizeHTML } from '../utils/sanitizeHTML'
import { extractAudioLinks } from '../utils/transformAudioLinks'
import { validateEnv } from '../utils/env'
import Embed from './Embed.astro'
import Media from './Media.astro'

const { BASE_URL } = Astro.locals
const { post, isItem } = Astro.props

const validatedEnv = validateEnv({
  env: import.meta.env,
  runtimeEnv: Astro.locals?.runtime?.env,
  isDev: import.meta.env.DEV,
  isBuild: import.meta.env.PROD,
})

const locale = (getEnv(import.meta.env, Astro, 'LOCALE') ?? validatedEnv.locale) || ''
if (locale) {
  dayjs.locale(locale)
}

const timezone = (getEnv(import.meta.env, Astro, 'TIMEZONE') ?? validatedEnv.timezone) || 'UTC'
const channel = getEnv(import.meta.env, Astro, 'CHANNEL') ?? validatedEnv.channel
const COMMENTS = getEnv(import.meta.env, Astro, 'COMMENTS')
const envEmbedSetting = getEnv(import.meta.env, Astro, 'ENABLE_EMBEDS')
const envEmbedsEnabled = envEmbedSetting === undefined ? true : envEmbedSetting !== 'false'

type MediaItem = {
  kind?: string
  url?: string
  mime?: string
  caption?: string
}

type EmbedItem = {
  url: string
}

// --- Bandcamp-only helpers (local to this file) ---
const BC_STYLE = 'border: 0; width: 100%; max-width: 700px; height: 120px; display: block; margin: 0 auto;'
const BC_PRESET = 'size=large/bgcol=333333/linkcol=0f91ff/tracklist=false/artwork=small/transparent=true/'

function hasBandcampIframe(html: string): boolean {
  return /<iframe[^>]+src=["']https?:\/\/bandcamp\.com\/EmbeddedPlayer\//i.test(html)
}

function normalizeExistingBandcampIframes(html: string): string {
  return html.replace(
    /<iframe\b([^>]*?)\bsrc=(["'])(https?:)?\/\/bandcamp\.com\/EmbeddedPlayer\/([^'"\s>]+)\2([^>]*)>\s*<\/iframe>/gi,
    (m, before, q, _proto, rest, after) => {
      const id = rest.match(/\b(album|track)=(\d+)/i)
      const newSrc = id
        ? `https://bandcamp.com/EmbeddedPlayer/${id[1].toLowerCase()}=${id[2]}/${BC_PRESET}`
        : `https://bandcamp.com/EmbeddedPlayer/${rest.split('?')[0].replace(/\/?$/, '/')}${BC_PRESET}`

      const cleanedBefore = stripAttr(before, 'style')
      const cleanedAfter = ensureAttr(stripAttr(after, 'style'), 'seamless')
      const needsLazy = !/\bloading\s*=\s*(["'])?lazy\1?/i.test(cleanedBefore + cleanedAfter)
      const lazyAttr = needsLazy ? ' loading="lazy"' : ''

      return `<iframe style="${BC_STYLE}" src="${newSrc}"${lazyAttr} ${cleanedBefore.trim()} ${cleanedAfter.trim()}></iframe>`
    },
  )
}

function dedupeBandcampIframes(html: string): string {
  const seen = new Set<string>()
  return html.replace(
    /<iframe\b[^>]*\bsrc=["']https?:\/\/bandcamp\.com\/EmbeddedPlayer\/(album|track)=(\d+)[^"']*["'][^>]*>\s*<\/iframe>/gi,
    (m, kind, id) => {
      const key = `${kind.toLowerCase()}:${id}`
      if (seen.has(key)) return ''
      seen.add(key)
      return m
    },
  )
}

// small attribute utils
function stripAttr(attrs: string, name: string): string {
  const re = new RegExp(`\\s${name}(\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s\"'=<>` + '`' + `]+))?`, 'gi')
  return attrs.replace(re, '')
}
function ensureAttr(attrs: string, name: string): string {
  return new RegExp(`\\b${name}\\b`, 'i').test(attrs) ? attrs : `${attrs} ${name}`
}

// Main wrapper to call right before set:html
function applyBandcampFix(renderedHtml: string): string {
  let html = renderedHtml
  if (hasBandcampIframe(html)) {
    html = normalizeExistingBandcampIframes(html)
  }
  html = dedupeBandcampIframes(html)
  return html
}

let safeContent = ''
let mediaList: MediaItem[] = []
let embedList: EmbedItem[] = []
let shouldRenderEmbeds = false
let renderError: Error | null = null

const fallbackText = typeof post?.text === 'string' ? post.text : ''
const fallbackSafeHtml = fallbackText ? sanitizeHTML(fallbackText) : ''
const fallbackLinkUrls = new Set<string>()

const allowListedUrl = (value: string | undefined | null) => {
  if (typeof value !== 'string') {
    return null
  }

  const trimmed = value.trim()
  if (!/^https?:/iu.test(trimmed)) {
    return null
  }

  return trimmed
}

if (Array.isArray(post?.embeds)) {
  post.embeds.forEach((embed) => {
    const safeUrl = allowListedUrl(embed?.url)
    if (safeUrl) {
      fallbackLinkUrls.add(safeUrl)
    }
  })
}

if (Array.isArray(post?.media)) {
  post.media.forEach((media) => {
    const safeUrl = allowListedUrl(media?.url)
    if (safeUrl) {
      fallbackLinkUrls.add(safeUrl)
    }
  })
}

const fallbackLinks = Array.from(fallbackLinkUrls).map((url) => ({ url }))

try {
  const rawContent = typeof post?.content === 'string' ? post.content : ''
  const sanitizedContent = rawContent ? sanitizeHTML(rawContent) : ''
  safeContent = sanitizedContent
  mediaList = Array.isArray(post?.media)
    ? post.media.filter((media): media is MediaItem =>
        Boolean(media && typeof media.url === 'string' && media.url.length > 0),
      )
    : []
  embedList = Array.isArray(post?.embeds)
    ? post.embeds
        .filter((embed): embed is EmbedItem => Boolean(embed && typeof embed.url === 'string' && embed.url.length > 0))
        .map((embed) => ({
          ...embed,
          url: typeof embed.url === 'string' ? embed.url : '',
        }))
    : []
  const normalizeAudioUrl = (value: string | undefined) => {
    if (typeof value !== 'string' || value.length === 0) {
      return ''
    }

    try {
      const normalized = new URL(value.replace(/^http:\/\//, 'https://'))
      normalized.hash = ''
      normalized.pathname = normalized.pathname.replace(/\/+$/, '')
      return normalized.toString()
    } catch {
      return value.trim()
    }
  }

  const existingAudio = new Set<string>()
  mediaList.forEach((media) => {
    if (media?.kind === 'audio' && typeof media.url === 'string') {
      existingAudio.add(normalizeAudioUrl(media.url))
    }
  })

  const contentTextForAudio = typeof post?.text === 'string' ? post.text : ''
  const audioFromText = extractAudioLinks(contentTextForAudio)
  for (const audio of audioFromText) {
    if (!audio?.url) {
      continue
    }

    const normalized = normalizeAudioUrl(audio.url)
    if (!normalized || existingAudio.has(normalized)) {
      continue
    }

    mediaList.push({ kind: 'audio', url: audio.url, mime: audio.mime })
    existingAudio.add(normalized)
  }
  const embedsEnabled = envEmbedsEnabled && (post?.embedsEnabled ?? envEmbedsEnabled)
  shouldRenderEmbeds = embedsEnabled && embedList.length > 0
} catch (error) {
  renderError = error instanceof Error ? error : new Error('Failed to render post content')
  if (import.meta.env.DEV) {
    console.warn('Failed to render post content', {
      id: post?.id,
      error: renderError,
    })
  }
}

const renderedFallbackHtml = fallbackSafeHtml ? applyBandcampFix(fallbackSafeHtml) : ''
const renderedContentHtml = safeContent ? applyBandcampFix(safeContent) : ''

const datetimeSource = typeof post?.datetime === 'string' ? post.datetime : ''
const datetime = (datetimeSource ? dayjs(datetimeSource) : dayjs()).tz(timezone)
const timeago = datetime.isBefore(dayjs().subtract(1, 'w')) ? datetime.format('HH:mm · ll · ddd') : datetime.fromNow()
---

<div class="item" style={{ 'view-transition-name': `post-${post.id}` }}>
  <div class="item-content-container">
    {
      renderError ? (
        <div class="text-box content">
          {renderedFallbackHtml.length > 0 ? (
            <div set:html={renderedFallbackHtml} />
          ) : (
            fallbackText.length > 0 && <p>{fallbackText}</p>
          )}
          {fallbackLinks.map((link) => (
            <p class="embed-fallback" key={`fallback-link-${link.url}`}>
              <a href={link.url} rel="noopener noreferrer nofollow ugc">
                {link.url}
              </a>
            </p>
          ))}
        </div>
      ) : (
        <Fragment>
          {renderedContentHtml.length > 0 && <div class={`text-box content`} set:html={renderedContentHtml} />}

          {mediaList.length > 0 && (
            <div class="media-list">
              {mediaList.map((media, index) => (
                <Media {...media} key={`media-${post.id ?? index}-${index}`} />
              ))}
            </div>
          )}

          {shouldRenderEmbeds && (
            <div class="embed-list">
              {embedList.map((embed, index) => (
                <div class="embed-item" key={`embed-${post.id ?? index}-${index}`}>
                  <Embed url={embed.url} />
                </div>
              ))}
            </div>
          )}
        </Fragment>
      )
    }
  </div>

  <div class="time-box">
    <div class="time">
      <a href={`${BASE_URL}posts/${post.id}`} title={post.datetime} class="time-link">
        <time datetime={post.datetime} title={timeago}>{timeago}</time>
      </a>
    </div>
  </div>

  {
    COMMENTS && isItem && (
      <div class="comments">
        <script
          is:inline
          async
          src="https://telegram.org/js/telegram-widget.js"
          data-telegram-discussion={`${channel}/${post.id}`}
          data-comments-limit="50"
          data-colorful="1"
          data-dark="1"
        />
      </div>
    )
  }
</div>
