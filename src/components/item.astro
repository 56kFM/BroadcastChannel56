---
import '../assets/item.css'
import 'prismjs/themes/prism.css'
import dayjs from '../lib/dayjs'
import { getEnv } from '../lib/env'
import { sanitizeHTML } from '../utils/sanitizeHTML'
import { extractAudioLinks } from '../utils/transformAudioLinks'
import { validateEnv } from '../utils/env'
import Embed from './Embed.astro'
import Media from './Media.astro'

const { BASE_URL } = Astro.locals
const BASE = Astro?.locals?.SITE_URL || Astro?.locals?.SITE_ORIGIN
const { post, isItem } = Astro.props

const postIdPathSegment = encodeURIComponent(String(post?.id))
const postPermalink = `${BASE_URL}posts/${postIdPathSegment}`

const validatedEnv = validateEnv({
  env: import.meta.env,
  runtimeEnv: Astro.locals?.runtime?.env,
  isDev: import.meta.env.DEV,
  isBuild: import.meta.env.PROD,
})

const locale = (getEnv(import.meta.env, Astro, 'LOCALE') ?? validatedEnv.locale) || ''
if (locale) {
  dayjs.locale(locale)
}

const timezone = (getEnv(import.meta.env, Astro, 'TIMEZONE') ?? validatedEnv.timezone) || 'UTC'
const channel = getEnv(import.meta.env, Astro, 'CHANNEL') ?? validatedEnv.channel
// Default ON unless explicitly "false" (case-insensitive)
const COMMENTS = (getEnv(import.meta.env, Astro, 'COMMENTS') ?? 'true').toString().trim().toLowerCase() !== 'false'
const envEmbedSetting = getEnv(import.meta.env, Astro, 'ENABLE_EMBEDS')
const envEmbedsEnabled = envEmbedSetting === undefined ? true : envEmbedSetting !== 'false'

type MediaItem = {
  kind?: string
  url?: string
  mime?: string
  caption?: string
}

type EmbedItem = {
  url: string
  oembedHtml?: string
}

// --- Bandcamp-only helpers (local to this file) ---
const BC_STYLE = 'border: 0; width: 100%; max-width: 700px; height: 120px; display: block; margin: 0 auto;'
const BC_PRESET = 'size=large/bgcol=333333/linkcol=0f91ff/tracklist=false/artwork=small/transparent=true/'

function hasBandcampIframe(html: string): boolean {
  return /<iframe[^>]+src=["']https?:\/\/bandcamp\.com\/EmbeddedPlayer\//i.test(html)
}

function normalizeExistingBandcampIframes(html: string): string {
  return html.replace(
    /<iframe\b([^>]*?)\bsrc=(["'])(https?:)?\/\/bandcamp\.com\/EmbeddedPlayer\/([^'"\s>]+)\2([^>]*)>\s*<\/iframe>/gi,
    (m, before, q, _proto, rest, after) => {
      const id = rest.match(/\b(album|track)=(\d+)/i)
      const newSrc = id
        ? `https://bandcamp.com/EmbeddedPlayer/${id[1].toLowerCase()}=${id[2]}/${BC_PRESET}`
        : `https://bandcamp.com/EmbeddedPlayer/${rest.split('?')[0].replace(/\/?$/, '/')}${BC_PRESET}`

      const cleanedBefore = stripAttr(before, 'style')
      const cleanedAfter = ensureAttr(stripAttr(after, 'style'), 'seamless')
      const needsLazy = !/\bloading\s*=\s*(["'])?lazy\1?/i.test(cleanedBefore + cleanedAfter)
      const lazyAttr = needsLazy ? ' loading="lazy"' : ''

      return `<iframe style="${BC_STYLE}" src="${newSrc}"${lazyAttr} ${cleanedBefore.trim()} ${cleanedAfter.trim()}></iframe>`
    },
  )
}

function dedupeBandcampIframes(html: string): string {
  const seen = new Set<string>()
  return html.replace(
    /<iframe\b[^>]*\bsrc=["']https?:\/\/bandcamp\.com\/EmbeddedPlayer\/(album|track)=(\d+)[^"']*["'][^>]*>\s*<\/iframe>/gi,
    (m, kind, id) => {
      const key = `${kind.toLowerCase()}:${id}`
      if (seen.has(key)) return ''
      seen.add(key)
      return m
    },
  )
}

// small attribute utils
function stripAttr(attrs: string, name: string): string {
  const re = new RegExp(`\\s${name}(\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s\"'=<>` + '`' + `]+))?`, 'gi')
  return attrs.replace(re, '')
}
function ensureAttr(attrs: string, name: string): string {
  return new RegExp(`\\b${name}\\b`, 'i').test(attrs) ? attrs : `${attrs} ${name}`
}

// Main wrapper to call right before set:html
function applyBandcampFix(renderedHtml: string): string {
  let html = renderedHtml
  if (hasBandcampIframe(html)) {
    html = normalizeExistingBandcampIframes(html)
  }
  html = dedupeBandcampIframes(html)
  return html
}

let safeContent = ''
let mediaList: MediaItem[] = []
let embedList: EmbedItem[] = []
let shouldRenderEmbeds = false
let renderError: Error | null = null

const fallbackText = typeof post?.text === 'string' ? post.text : ''
const fallbackSafeHtml = fallbackText ? sanitizeHTML(fallbackText, { baseUrl: BASE }) : ''
const fallbackLinkUrls = new Set<string>()

const allowListedUrl = (value: string | undefined | null) => {
  if (typeof value !== 'string') {
    return null
  }

  const trimmed = value.trim()
  if (!/^https?:/iu.test(trimmed)) {
    return null
  }

  return trimmed
}

if (Array.isArray(post?.embeds)) {
  post.embeds.forEach((embed: any) => {
    const safeUrl = allowListedUrl(embed?.url)
    if (safeUrl) {
      fallbackLinkUrls.add(safeUrl)
    }
  })
}

if (Array.isArray(post?.media)) {
  post.media.forEach((media: any) => {
    const safeUrl = allowListedUrl(media?.url)
    if (safeUrl) {
      fallbackLinkUrls.add(safeUrl)
    }
  })
}

const fallbackLinks = Array.from(fallbackLinkUrls).map((url) => ({ url }))

let structuredData = null

try {
  const rawContent = typeof post?.content === 'string' ? post.content : ''
  const sanitizedContent = rawContent ? sanitizeHTML(rawContent, { baseUrl: BASE }) : ''
  safeContent = sanitizedContent
  mediaList = Array.isArray(post?.media)
    ? post.media.filter((media: any): media is MediaItem =>
        Boolean(media && typeof media.url === 'string' && media.url.length > 0),
      )
    : []
  embedList = Array.isArray(post?.embeds)
    ? post.embeds
        .filter((embed: any): embed is EmbedItem =>
          Boolean(
            embed && ((typeof embed.url === 'string' && embed.url.length > 0) || typeof embed.oembedHtml === 'string'),
          ),
        )
        .map((embed: any) => ({
          ...embed,
          url: typeof embed.url === 'string' ? embed.url : '',
        }))
    : []

  // Bandcamp de-duplication: keep only the first Bandcamp embed to avoid duplicate players
  if (embedList.length > 1) {
    const out: Array<{ url: string }> = []
    let seenBandcamp = false
    for (const e of embedList) {
      try {
        const h = new URL(e.url).hostname.toLowerCase()
        const isBC = h === 'bandcamp.com' || h.endsWith('.bandcamp.com')
        if (isBC) {
          if (seenBandcamp) continue
          seenBandcamp = true
        }
        out.push(e)
      } catch {
        out.push(e)
      }
    }
    embedList = out
  }

  // If Telegram didn't provide provider embeds, allow a minimal inline->embed promotion
  // Use only allow-listed providers and only when no provider embed exists to avoid duplicates.
  const ALLOWED_EMBED_HOSTS = [
    'youtu.be',
    'youtube.com',
    'www.youtube.com',
    'www.youtube-nocookie.com',
    'vimeo.com',
    'www.vimeo.com',
    'player.vimeo.com',
    'soundcloud.com',
    'w.soundcloud.com',
    'open.spotify.com',
    'bandcamp.com',
    'embed.music.apple.com',
  ] as const

  function extractInlineEmbedUrlsFromText(text: string): string[] {
    const out = new Set<string>()
    if (typeof text !== 'string' || text.length === 0) return []
    const urlRe = /\bhttps?:\/\/[^\s<>"']+/gi
    for (const m of text.matchAll(urlRe)) {
      const u = allowListedUrl(m[0])
      if (!u) continue
      try {
        const h = new URL(u).hostname.toLowerCase()
        if (ALLOWED_EMBED_HOSTS.some((ah) => h === ah || h.endsWith('.' + ah))) {
          out.add(u)
        }
      } catch {}
    }
    return Array.from(out)
  }

  if (embedList.length === 0) {
    const inlineCandidates = [
      ...extractInlineEmbedUrlsFromText(fallbackText),
      ...extractInlineEmbedUrlsFromText(fallbackSafeHtml),
    ]
    const existing = new Set(embedList.map((e) => e.url))
    for (const u of inlineCandidates) {
      if (!existing.has(u)) {
        embedList.push({ url: u })
        if (embedList.length >= 2) break
      }
    }
  }
  const normalizeAudioUrl = (value: string | undefined) => {
    if (typeof value !== 'string' || value.length === 0) {
      return ''
    }

    try {
      const normalized = new URL(value.replace(/^http:\/\//, 'https://'))
      normalized.hash = ''
      normalized.pathname = normalized.pathname.replace(/\/+$/, '')
      return normalized.toString()
    } catch {
      return value.trim()
    }
  }

  const existingAudio = new Set<string>()
  mediaList.forEach((media: any) => {
    if (media?.kind === 'audio' && typeof media.url === 'string') {
      existingAudio.add(normalizeAudioUrl(media.url))
    }
  })

  const contentTextForAudio = typeof post?.text === 'string' ? post.text : ''
  const audioFromText = extractAudioLinks(contentTextForAudio)
  for (const audio of audioFromText) {
    if (!audio?.url) {
      continue
    }

    const normalized = normalizeAudioUrl(audio.url)
    if (!normalized || existingAudio.has(normalized)) {
      continue
    }

    mediaList.push({ kind: 'audio', url: audio.url, mime: audio.mime })
    existingAudio.add(normalized)
  }
  const embedsEnabled = envEmbedsEnabled && (post?.embedsEnabled ?? envEmbedsEnabled)
  shouldRenderEmbeds = embedsEnabled && embedList.length > 0
} catch (error) {
  renderError = error instanceof Error ? error : new Error('Failed to render post content')
  if (import.meta.env.DEV) {
    console.warn('Failed to render post content', {
      id: post?.id,
      error: renderError,
    })
  }
}

const renderedFallbackHtml = fallbackSafeHtml ? applyBandcampFix(fallbackSafeHtml) : ''
const renderedContentHtml = safeContent ? applyBandcampFix(safeContent) : ''

const imageItems = mediaList.filter((m) => m?.kind === 'image')
const otherMedia = mediaList.filter((m) => m?.kind !== 'image')

const datetimeSource = typeof post?.datetime === 'string' ? post.datetime : ''
const datetime = (datetimeSource ? dayjs(datetimeSource) : dayjs()).tz(timezone)
const timeago = datetime.isBefore(dayjs().subtract(1, 'w')) ? datetime.format('HH:mm · ll · ddd') : datetime.fromNow()

if (isItem) {
  const plainHeadlineSource = fallbackText.replace(/\s+/g, ' ').trim()
  const baseHeadline = plainHeadlineSource || channel || ''
  const maxHeadlineLength = 110
  const truncatedHeadline =
    baseHeadline.length > maxHeadlineLength ? `${baseHeadline.slice(0, maxHeadlineLength).trimEnd()}…` : baseHeadline
  const headline = truncatedHeadline

  let imageUrl = null
  if (!imageUrl && Array.isArray(post?.media)) {
    for (const media of post.media) {
      const safeUrl = allowListedUrl(media?.url)
      if (!safeUrl) {
        continue
      }

      const kind = typeof media?.kind === 'string' ? media.kind.toLowerCase() : ''
      const mime = typeof media?.mime === 'string' ? media.mime.toLowerCase() : ''
      if (kind.includes('image') || kind.includes('photo') || mime.startsWith('image/')) {
        imageUrl = safeUrl
        break
      }
    }
  }

  const ldAuthorName = typeof channel === 'string' && channel.length > 0 ? channel : undefined
  const ldObject = {
    '@context': 'https://schema.org',
    '@type': 'SocialMediaPosting',
    mainEntityOfPage: postPermalink,
    headline,
    author: ldAuthorName
      ? {
          '@type': 'Organization',
          name: ldAuthorName,
        }
      : undefined,
    url: postPermalink,
  }

  if (datetimeSource) {
    ldObject.datePublished = datetimeSource
  }

  if (imageUrl) {
    ldObject.image = imageUrl
  }

  if (!ldObject.author) {
    delete ldObject.author
  }

  structuredData = ldObject
}

const structuredDataJson = structuredData ? JSON.stringify(structuredData) : ''
---

<Fragment>
  {isItem && structuredDataJson && <script type="application/ld+json" is:inline set:html={structuredDataJson} />}

  <div class="item" style={{ 'view-transition-name': `post-${post.id}` }}>
    <div class="item-content-container">
      {
        renderError ? (
          <div class="text-box content">
            {renderedFallbackHtml.length > 0 ? (
              <div set:html={renderedFallbackHtml} />
            ) : (
              fallbackText.length > 0 && <p>{fallbackText}</p>
            )}
            {fallbackLinks.map((link) => (
              <p class="embed-fallback">
                <a href={link.url} rel="noopener noreferrer nofollow ugc">
                  {link.url}
                </a>
              </p>
            ))}
          </div>
        ) : (
          <Fragment>
            {renderedContentHtml.length > 0 && <div class={`text-box content`} set:html={renderedContentHtml} />}

            {imageItems.length > 0 && (
              <>
                {/* Hero first image */}
                <div class="media-hero">
                  {(() => {
                    const first = imageItems[0]
                    return first ? (
                      <a
                        class="image-preview-link image-preview-wrap"
                        href={first.url}
                        target="_blank"
                        rel="noopener noreferrer"
                      >
                        <img src={first.url} alt={first.caption || 'Image'} loading="eager" decoding="async" />
                      </a>
                    ) : null
                  })()}
                </div>

                {/* Masonry for remaining images */}
                {imageItems.length > 1 && (
                  <div class="image-list-container media-masonry">
                    {imageItems.slice(1).map(({ url, caption }, i) => (
                      <a
                        class="image-preview-link image-preview-wrap"
                        href={url}
                        target="_blank"
                        rel="noopener noreferrer"
                      >
                        <img src={url} alt={caption || 'Image'} loading="lazy" decoding="async" />
                      </a>
                    ))}
                  </div>
                )}
              </>
            )}

            {otherMedia.length > 0 && (
              <div class="media-list">
                {otherMedia.map((m) => (
                  <Media {...m} />
                ))}
              </div>
            )}

            {shouldRenderEmbeds && (
              <div class="embed-list">
                {embedList.map((embed, _index) => (
                  <div class="embed-item">
                    <Embed url={embed.url} oembedHtml={embed.oembedHtml} />
                  </div>
                ))}
              </div>
            )}
          </Fragment>
        )
      }
    </div>

    <div class="time-box">
      <div class="time">
        <a href={postPermalink} title={post.datetime} class="time-link">
          <time datetime={post.datetime} title={timeago}>{timeago}</time>
        </a>
      </div>
    </div>

    {
      COMMENTS && isItem && post?.id && (
        <div class="comments">
          <script
            is:inline
            async
            src="https://telegram.org/js/telegram-widget.js"
            data-telegram-discussion={`${channel}/${post.id}`}
            data-comments-limit="50"
            data-colorful="1"
            data-dark="1"
          />
        </div>
      )
    }
  </div>
</Fragment>
