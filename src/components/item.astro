---
import '../assets/item.css'
import 'prismjs/themes/prism.css'
import dayjs from '../lib/dayjs'
import { getEnv } from '../lib/env'
import { sanitizeHTML } from '../utils/sanitizeHTML'
import { extractAudioLinks } from '../utils/transformAudioLinks'
import { validateEnv } from '../utils/env'
import Embed from './Embed.astro'
import Media from './Media.astro'

const { BASE_URL } = Astro.locals
const { post, isItem } = Astro.props

const postIdPathSegment = encodeURIComponent(String(post?.id))
const postPermalink = `${BASE_URL}posts/${postIdPathSegment}`

const validatedEnv = validateEnv({
  env: import.meta.env,
  runtimeEnv: Astro.locals?.runtime?.env,
  isDev: import.meta.env.DEV,
  isBuild: import.meta.env.PROD,
})

const locale = (getEnv(import.meta.env, Astro, 'LOCALE') ?? validatedEnv.locale) || ''
if (locale) {
  dayjs.locale(locale)
}

const timezone = (getEnv(import.meta.env, Astro, 'TIMEZONE') ?? validatedEnv.timezone) || 'UTC'
const channel = getEnv(import.meta.env, Astro, 'CHANNEL') ?? validatedEnv.channel
// Default ON unless explicitly "false" (case-insensitive)
const COMMENTS = (getEnv(import.meta.env, Astro, 'COMMENTS') ?? 'true').toString().trim().toLowerCase() !== 'false'
const envEmbedSetting = getEnv(import.meta.env, Astro, 'ENABLE_EMBEDS')
const envEmbedsEnabled = envEmbedSetting === undefined ? true : envEmbedSetting !== 'false'

type MediaItem = {
  kind?: string
  url?: string
  mime?: string
  caption?: string
}

type EmbedItem = {
  url: string
  oembedHtml?: string
}

// --- Bandcamp-only helpers (local to this file) ---
const BC_STYLE = 'border: 0; width: 100%; max-width: 700px; height: 120px; display: block; margin: 0 auto;'
const BC_PRESET = 'size=large/bgcol=333333/linkcol=0f91ff/tracklist=false/artwork=small/transparent=true/'

function hasBandcampIframe(html: string): boolean {
  return /<iframe[^>]+src=["']https?:\/\/bandcamp\.com\/EmbeddedPlayer\//i.test(html)
}

function normalizeExistingBandcampIframes(html: string): string {
  return html.replace(
    /<iframe\b([^>]*?)\bsrc=(["'])(https?:)?\/\/bandcamp\.com\/EmbeddedPlayer\/([^'"\s>]+)\2([^>]*)>\s*<\/iframe>/gi,
    (m, before, q, _proto, rest, after) => {
      const id = rest.match(/\b(album|track)=(\d+)/i)
      const newSrc = id
        ? `https://bandcamp.com/EmbeddedPlayer/${id[1].toLowerCase()}=${id[2]}/${BC_PRESET}`
        : `https://bandcamp.com/EmbeddedPlayer/${rest.split('?')[0].replace(/\/?$/, '/')}${BC_PRESET}`

      const cleanedBefore = stripAttr(before, 'style')
      const cleanedAfter = ensureAttr(stripAttr(after, 'style'), 'seamless')
      const needsLazy = !/\bloading\s*=\s*(["'])?lazy\1?/i.test(cleanedBefore + cleanedAfter)
      const lazyAttr = needsLazy ? ' loading="lazy"' : ''

      return `<iframe style="${BC_STYLE}" src="${newSrc}"${lazyAttr} ${cleanedBefore.trim()} ${cleanedAfter.trim()}></iframe>`
    },
  )
}

function dedupeBandcampIframes(html: string): string {
  const seen = new Set<string>()
  return html.replace(
    /<iframe\b[^>]*\bsrc=["']https?:\/\/bandcamp\.com\/EmbeddedPlayer\/(album|track)=(\d+)[^"']*["'][^>]*>\s*<\/iframe>/gi,
    (m, kind, id) => {
      const key = `${kind.toLowerCase()}:${id}`
      if (seen.has(key)) return ''
      seen.add(key)
      return m
    },
  )
}

// small attribute utils
function stripAttr(attrs: string, name: string): string {
  const re = new RegExp(`\\s${name}(\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s\"'=<>` + '`' + `]+))?`, 'gi')
  return attrs.replace(re, '')
}
function ensureAttr(attrs: string, name: string): string {
  return new RegExp(`\\b${name}\\b`, 'i').test(attrs) ? attrs : `${attrs} ${name}`
}

// Main wrapper to call right before set:html
function applyBandcampFix(renderedHtml: string): string {
  let html = renderedHtml
  if (hasBandcampIframe(html)) {
    html = normalizeExistingBandcampIframes(html)
  }
  html = dedupeBandcampIframes(html)
  return html
}

let safeContent = ''
let mediaList: MediaItem[] = []
let embedList: EmbedItem[] = []
let shouldRenderEmbeds = false
let renderError: Error | null = null

const fallbackText = typeof post?.text === 'string' ? post.text : ''
const fallbackSafeHtml = fallbackText ? sanitizeHTML(fallbackText) : ''
const fallbackLinkUrls = new Set<string>()

const allowListedUrl = (value: string | undefined | null) => {
  if (typeof value !== 'string') {
    return null
  }

  const trimmed = value.trim()
  if (!/^https?:/iu.test(trimmed)) {
    return null
  }

  return trimmed
}

if (Array.isArray(post?.embeds)) {
  post.embeds.forEach((embed) => {
    const safeUrl = allowListedUrl(embed?.url)
    if (safeUrl) {
      fallbackLinkUrls.add(safeUrl)
    }
  })
}

if (Array.isArray(post?.media)) {
  post.media.forEach((media) => {
    const safeUrl = allowListedUrl(media?.url)
    if (safeUrl) {
      fallbackLinkUrls.add(safeUrl)
    }
  })
}

const fallbackLinks = Array.from(fallbackLinkUrls).map((url) => ({ url }))

try {
  const rawContent = typeof post?.content === 'string' ? post.content : ''
  const sanitizedContent = rawContent ? sanitizeHTML(rawContent) : ''
  safeContent = sanitizedContent
  mediaList = Array.isArray(post?.media)
    ? post.media.filter((media): media is MediaItem =>
        Boolean(media && typeof media.url === 'string' && media.url.length > 0),
      )
    : []
  embedList = Array.isArray(post?.embeds)
    ? post.embeds
        .filter((embed): embed is EmbedItem =>
          Boolean(
            embed && ((typeof embed.url === 'string' && embed.url.length > 0) || typeof embed.oembedHtml === 'string'),
          ),
        )
        .map((embed) => ({
          ...embed,
          url: typeof embed.url === 'string' ? embed.url : '',
        }))
    : []

  // Bandcamp de-duplication: keep only the first Bandcamp embed to avoid duplicate players
  if (embedList.length > 1) {
    const out: Array<{ url: string }> = []
    let seenBandcamp = false
    for (const e of embedList) {
      try {
        const h = new URL(e.url).hostname.toLowerCase()
        const isBC = h === 'bandcamp.com' || h.endsWith('.bandcamp.com')
        if (isBC) {
          if (seenBandcamp) continue
          seenBandcamp = true
        }
        out.push(e)
      } catch {
        out.push(e)
      }
    }
    embedList = out
  }

  // If Telegram didn't provide provider embeds, allow a minimal inline->embed promotion
  // Use only allow-listed providers and only when no provider embed exists to avoid duplicates.
  const ALLOWED_EMBED_HOSTS = [
    'youtu.be',
    'youtube.com',
    'www.youtube.com',
    'www.youtube-nocookie.com',
    'vimeo.com',
    'www.vimeo.com',
    'player.vimeo.com',
    'soundcloud.com',
    'w.soundcloud.com',
    'open.spotify.com',
    'bandcamp.com',
    'embed.music.apple.com',
  ] as const

  function extractInlineEmbedUrlsFromText(text: string): string[] {
    const out = new Set<string>()
    if (typeof text !== 'string' || text.length === 0) return []
    const urlRe = /\bhttps?:\/\/[^\s<>"']+/gi
    for (const m of text.matchAll(urlRe)) {
      const u = allowListedUrl(m[0])
      if (!u) continue
      try {
        const h = new URL(u).hostname.toLowerCase()
        if (ALLOWED_EMBED_HOSTS.some((ah) => h === ah || h.endsWith('.' + ah))) {
          out.add(u)
        }
      } catch {}
    }
    return Array.from(out)
  }

  if (embedList.length === 0) {
    const inlineCandidates = [
      ...extractInlineEmbedUrlsFromText(fallbackText),
      ...extractInlineEmbedUrlsFromText(fallbackSafeHtml),
    ]
    const existing = new Set(embedList.map((e) => e.url))
    for (const u of inlineCandidates) {
      if (!existing.has(u)) {
        embedList.push({ url: u })
        if (embedList.length >= 2) break
      }
    }
  }
  const normalizeAudioUrl = (value: string | undefined) => {
    if (typeof value !== 'string' || value.length === 0) {
      return ''
    }

    try {
      const normalized = new URL(value.replace(/^http:\/\//, 'https://'))
      normalized.hash = ''
      normalized.pathname = normalized.pathname.replace(/\/+$/, '')
      return normalized.toString()
    } catch {
      return value.trim()
    }
  }

  const existingAudio = new Set<string>()
  mediaList.forEach((media) => {
    if (media?.kind === 'audio' && typeof media.url === 'string') {
      existingAudio.add(normalizeAudioUrl(media.url))
    }
  })

  const contentTextForAudio = typeof post?.text === 'string' ? post.text : ''
  const audioFromText = extractAudioLinks(contentTextForAudio)
  for (const audio of audioFromText) {
    if (!audio?.url) {
      continue
    }

    const normalized = normalizeAudioUrl(audio.url)
    if (!normalized || existingAudio.has(normalized)) {
      continue
    }

    mediaList.push({ kind: 'audio', url: audio.url, mime: audio.mime })
    existingAudio.add(normalized)
  }
  const embedsEnabled = envEmbedsEnabled && (post?.embedsEnabled ?? envEmbedsEnabled)
  shouldRenderEmbeds = embedsEnabled && embedList.length > 0
} catch (error) {
  renderError = error instanceof Error ? error : new Error('Failed to render post content')
  if (import.meta.env.DEV) {
    console.warn('Failed to render post content', {
      id: post?.id,
      error: renderError,
    })
  }
}

const renderedFallbackHtml = fallbackSafeHtml ? applyBandcampFix(fallbackSafeHtml) : ''
const renderedContentHtml = safeContent ? applyBandcampFix(safeContent) : ''

const datetimeSource = typeof post?.datetime === 'string' ? post.datetime : ''
const datetime = (datetimeSource ? dayjs(datetimeSource) : dayjs()).tz(timezone)
const timeago = datetime.isBefore(dayjs().subtract(1, 'w')) ? datetime.format('HH:mm · ll · ddd') : datetime.fromNow()
---

<div class="item" style={{ 'view-transition-name': `post-${post.id}` }}>
  <div class="item-content-container">
    {
      renderError ? (
        <div class="text-box content">
          {renderedFallbackHtml.length > 0 ? (
            <div set:html={renderedFallbackHtml} />
          ) : (
            fallbackText.length > 0 && <p>{fallbackText}</p>
          )}
          {fallbackLinks.map((link) => (
            <p class="embed-fallback">
              <a href={link.url} rel="noopener noreferrer nofollow ugc">
                {link.url}
              </a>
            </p>
          ))}
        </div>
      ) : (
        <Fragment>
          {renderedContentHtml.length > 0 && <div class={`text-box content`} set:html={renderedContentHtml} />}

          {mediaList.length > 0 && (
            <div class="media-list">
              {mediaList.map((media, index) => (
                <Media {...media} />
              ))}
            </div>
          )}

          {shouldRenderEmbeds && (
            <div class="embed-list">
              {embedList.map((embed, index) => (
                <div class="embed-item">
                  <Embed url={embed.url} oembedHtml={embed.oembedHtml} />
                </div>
              ))}
            </div>
          )}
        </Fragment>
      )
    }
  </div>

  <div class="time-box">
    <div class="time">
      <a href={postPermalink} title={post.datetime} class="time-link">
        <time datetime={post.datetime} title={timeago}>{timeago}</time>
      </a>
    </div>
  </div>

  {
    COMMENTS && isItem && post?.id && (
      <div class="comments">
        <script
          async
          src="https://telegram.org/js/telegram-widget.js"
          data-telegram-discussion={`${channel}/${post.id}`}
          data-comments-limit="50"
          data-colorful="1"
          data-dark="1"
        />
      </div>
    )
  }
</div>
