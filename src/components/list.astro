---
import Layout from '../layouts/base.astro'
import Header from '../components/header.astro'
import Item from '../components/item.astro'

const { BASE_URL } = Astro.locals
const {
  channel,
  before = true,
  after = true,
  isItem = false,
  paginationGap = false,
  paginationBasePath = '',
} = Astro.props

/* PAGINATION_START */
const posts = Array.isArray(channel?.posts) ? channel.posts : []
const normalizedBasePath = paginationBasePath ? `${paginationBasePath.replace(/^\/+/u, '').replace(/\/+$/u, '')}/` : ''
const encodeCursor = (cursor: unknown) => encodeURIComponent(String(cursor))

const singlePost = isItem ? (posts.at(-1) ?? posts[0]) : undefined
const oldestPost = posts[0]
const newestPost = posts.at(-1)

const beforeCursor = isItem ? singlePost?.id : oldestPost?.id
const afterCursor = isItem ? singlePost?.id : newestPost?.id

const beforeHref =
  typeof beforeCursor === 'undefined' ? '' : `${BASE_URL}${normalizedBasePath}before/${encodeCursor(beforeCursor)}`
const afterHref =
  typeof afterCursor === 'undefined' ? '' : `${BASE_URL}${normalizedBasePath}after/${encodeCursor(afterCursor)}`

// Prefer server-provided flags; fall back to heuristic
const numericIds = posts
  .map((post) => Number.parseInt(post?.id ?? '', 10))
  .filter((value) => Number.isFinite(value))
  .sort((a, b) => a - b)
const pickedId =
  isItem && Number.isFinite(Number.parseInt(singlePost?.id ?? '', 10))
    ? Number.parseInt(singlePost?.id ?? '', 10)
    : undefined
const oldestId = numericIds[0]
const newestId = numericIds.at(-1)

const serverHasOlder = typeof channel?.hasOlder === 'boolean' ? channel.hasOlder : undefined
const serverHasNewer = typeof channel?.hasNewer === 'boolean' ? channel.hasNewer : undefined

const fallbackHasOlder = (() => {
  if (!beforeCursor) {
    return false
  }
  if (!numericIds.length) {
    return false
  }
  if (isItem && Number.isFinite(pickedId) && Number.isFinite(oldestId)) {
    return pickedId > oldestId
  }
  return !isItem && posts.length > 0
})()

const fallbackHasNewer = (() => {
  if (!afterCursor) {
    return false
  }
  if (!numericIds.length) {
    return false
  }
  if (isItem && Number.isFinite(pickedId) && Number.isFinite(newestId)) {
    return pickedId < newestId
  }
  return !isItem && posts.length > 0
})()

const hasOlderPosts = Boolean(before) && (serverHasOlder ?? fallbackHasOlder ?? false)
const hasNewerPosts = Boolean(after) && (serverHasNewer ?? fallbackHasNewer ?? false)
/* PAGINATION_END */
/**
 * NOTE: Feed page size is controlled by the repo’s custom paginator.
 * The custom paginator is the source of truth for per-page limits.
 * Do not add separate per-page limits (env/const) here to avoid duplication.
 */
const paginationClassList = {
  'pages-container': true,
  'pages-container--with-gap': paginationGap,
}
---

<Layout channel={channel} id="main-container">
  <slot name="header">
    <Header channel={channel} />
  </slot>
  <div class="items">
    {posts.map((_post, _index) => <Item post={_post} isItem={isItem} />)}
  </div>

  <div class:list={paginationClassList}>
    {
      hasOlderPosts ? (
        <a href={beforeHref} title="before" class="page" aria-label="Go to older post" rel="prev">
          ◀◀
        </a>
      ) : (
        <span class="page-placeholder">&nbsp;</span>
      )
    }

    <div class="pages-info"></div>
    {
      hasNewerPosts ? (
        <a href={afterHref} title="after" class="page" aria-label="Go to newer post" rel="next">
          ▶▶
        </a>
      ) : (
        <span class="page-placeholder">&nbsp;</span>
      )
    }
  </div>

  <Fragment slot="head">
    {isItem && hasOlderPosts && beforeHref ? <link rel="prefetch" href={beforeHref} as="document" /> : null}
    {isItem && hasNewerPosts && afterHref ? <link rel="prefetch" href={afterHref} as="document" /> : null}
    {isItem && hasOlderPosts && beforeHref ? <link rel="prev" href={beforeHref} /> : null}
    {isItem && hasNewerPosts && afterHref ? <link rel="next" href={afterHref} /> : null}
  </Fragment>
</Layout>
